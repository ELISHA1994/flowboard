"""Add webhook delivery status enum and update webhook delivery model

Revision ID: 5fd2611561bb
Revises: 10b51d22e687
Create Date: 2025-07-20 06:03:44.588595

Description:
    TODO: Add detailed description of what this migration does

Safety Notes:
    TODO: Document any potential risks or considerations

Rollback Plan:
    TODO: Document how to safely rollback if needed
"""

from typing import Sequence, Union
import logging

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql, mysql, sqlite
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "5fd2611561bb"
down_revision: Union[str, None] = "10b51d22e687"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# Configure logging
logger = logging.getLogger(__name__)


def upgrade() -> None:
    """
    Apply the migration.

    This function should be idempotent when possible.
    """
    logger.info(f"Applying migration {revision}")

    # Get database dialect for conditional operations
    connection = op.get_bind()
    dialect_name = connection.dialect.name

    try:
        # ### commands auto generated by Alembic - please adjust! ###
        # Create the enum type first
        webhook_status_enum = sa.Enum(
            "PENDING", "DELIVERED", "FAILED", name="webhookdeliverystatus"
        )
        webhook_status_enum.create(op.get_bind())

        op.add_column(
            "webhook_deliveries",
            sa.Column("status", webhook_status_enum, nullable=False),
        )
        op.add_column(
            "webhook_deliveries",
            sa.Column("response_status_code", sa.Integer(), nullable=True),
        )
        op.add_column(
            "webhook_deliveries",
            sa.Column("response_headers", sa.Text(), nullable=True),
        )
        op.add_column(
            "webhook_deliveries", sa.Column("response_body", sa.Text(), nullable=True)
        )
        op.add_column(
            "webhook_deliveries", sa.Column("failure_reason", sa.Text(), nullable=True)
        )
        op.add_column(
            "webhook_deliveries",
            sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
        )
        op.alter_column(
            "webhook_deliveries",
            "delivered_at",
            existing_type=postgresql.TIMESTAMP(timezone=True),
            nullable=True,
        )
        op.drop_column("webhook_deliveries", "next_retry_at")
        op.drop_column("webhook_deliveries", "response")
        op.drop_column("webhook_deliveries", "error")
        op.drop_column("webhook_deliveries", "status_code")
        # ### end Alembic commands ###

        logger.info(f"Successfully applied migration {revision}")
    except Exception as e:
        logger.error(f"Failed to apply migration {revision}: {str(e)}")
        raise


def downgrade() -> None:
    """
    Rollback the migration.

    This function should safely undo all changes made in upgrade().
    """
    logger.info(f"Rolling back migration {revision}")

    # Get database dialect for conditional operations
    connection = op.get_bind()
    dialect_name = connection.dialect.name

    try:
        # ### commands auto generated by Alembic - please adjust! ###
        op.add_column(
            "webhook_deliveries",
            sa.Column("status_code", sa.INTEGER(), autoincrement=False, nullable=True),
        )
        op.add_column(
            "webhook_deliveries",
            sa.Column("error", sa.TEXT(), autoincrement=False, nullable=True),
        )
        op.add_column(
            "webhook_deliveries",
            sa.Column("response", sa.TEXT(), autoincrement=False, nullable=True),
        )
        op.add_column(
            "webhook_deliveries",
            sa.Column(
                "next_retry_at",
                postgresql.TIMESTAMP(timezone=True),
                autoincrement=False,
                nullable=True,
            ),
        )
        op.alter_column(
            "webhook_deliveries",
            "delivered_at",
            existing_type=postgresql.TIMESTAMP(timezone=True),
            nullable=False,
        )
        op.drop_column("webhook_deliveries", "created_at")
        op.drop_column("webhook_deliveries", "failure_reason")
        op.drop_column("webhook_deliveries", "response_body")
        op.drop_column("webhook_deliveries", "response_headers")
        op.drop_column("webhook_deliveries", "response_status_code")
        op.drop_column("webhook_deliveries", "status")

        # Drop the enum type
        webhook_status_enum = sa.Enum(
            "PENDING", "DELIVERED", "FAILED", name="webhookdeliverystatus"
        )
        webhook_status_enum.drop(op.get_bind())
        # ### end Alembic commands ###

        logger.info(f"Successfully rolled back migration {revision}")
    except Exception as e:
        logger.error(f"Failed to rollback migration {revision}: {str(e)}")
        raise


# Helper functions for common migration tasks
def create_index_if_not_exists(index_name: str, table_name: str, columns: list):
    """Create an index only if it doesn't already exist."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    indexes = [idx["name"] for idx in inspector.get_indexes(table_name)]

    if index_name not in indexes:
        op.create_index(index_name, table_name, columns)
        logger.info(f"Created index {index_name} on {table_name}")
    else:
        logger.info(f"Index {index_name} already exists on {table_name}")


def drop_index_if_exists(index_name: str, table_name: str):
    """Drop an index only if it exists."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    indexes = [idx["name"] for idx in inspector.get_indexes(table_name)]

    if index_name in indexes:
        op.drop_index(index_name, table_name)
        logger.info(f"Dropped index {index_name} from {table_name}")
    else:
        logger.info(f"Index {index_name} does not exist on {table_name}")


def add_column_if_not_exists(table_name: str, column: sa.Column):
    """Add a column only if it doesn't already exist."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    columns = [col["name"] for col in inspector.get_columns(table_name)]

    if column.name not in columns:
        op.add_column(table_name, column)
        logger.info(f"Added column {column.name} to {table_name}")
    else:
        logger.info(f"Column {column.name} already exists in {table_name}")


def drop_column_if_exists(table_name: str, column_name: str):
    """Drop a column only if it exists."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    columns = [col["name"] for col in inspector.get_columns(table_name)]

    if column_name in columns:
        op.drop_column(table_name, column_name)
        logger.info(f"Dropped column {column_name} from {table_name}")
    else:
        logger.info(f"Column {column_name} does not exist in {table_name}")
