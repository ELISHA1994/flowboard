"""Add TaskActivity model for comprehensive activity tracking

Revision ID: b397b78163be
Revises: 5fd2611561bb
Create Date: 2025-07-21 04:40:59.539276

Description:
    TODO: Add detailed description of what this migration does

Safety Notes:
    TODO: Document any potential risks or considerations

Rollback Plan:
    TODO: Document how to safely rollback if needed
"""

from typing import Sequence, Union
import logging

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql, mysql, sqlite


# revision identifiers, used by Alembic.
revision: str = "b397b78163be"
down_revision: Union[str, None] = "5fd2611561bb"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# Configure logging
logger = logging.getLogger(__name__)


def upgrade() -> None:
    """
    Apply the migration.

    This function should be idempotent when possible.
    """
    logger.info(f"Applying migration {revision}")

    # Get database dialect for conditional operations
    connection = op.get_bind()
    dialect_name = connection.dialect.name

    try:
        # ### commands auto generated by Alembic - please adjust! ###
        op.create_table(
            "task_activities",
            sa.Column("id", sa.String(), nullable=False),
            sa.Column("task_id", sa.String(), nullable=False),
            sa.Column("user_id", sa.String(), nullable=True),
            sa.Column(
                "activity_type",
                sa.Enum(
                    "CREATED",
                    "STATUS_CHANGED",
                    "PRIORITY_CHANGED",
                    "ASSIGNED",
                    "UNASSIGNED",
                    "DUE_DATE_CHANGED",
                    "START_DATE_CHANGED",
                    "TITLE_CHANGED",
                    "DESCRIPTION_CHANGED",
                    "COMMENT_ADDED",
                    "COMMENT_EDITED",
                    "COMMENT_DELETED",
                    "ATTACHMENT_ADDED",
                    "ATTACHMENT_DELETED",
                    "TIME_LOGGED",
                    "DEPENDENCY_ADDED",
                    "DEPENDENCY_REMOVED",
                    "SUBTASK_ADDED",
                    "SUBTASK_REMOVED",
                    "SHARED",
                    "UNSHARED",
                    "PROJECT_CHANGED",
                    "TAG_ADDED",
                    "TAG_REMOVED",
                    "CATEGORY_ADDED",
                    "CATEGORY_REMOVED",
                    "COMPLETED",
                    "REOPENED",
                    "DELETED",
                    name="activitytype",
                ),
                nullable=False,
            ),
            sa.Column("details", sa.Text(), nullable=True),
            sa.Column("old_value", sa.Text(), nullable=True),
            sa.Column("new_value", sa.Text(), nullable=True),
            sa.Column("ip_address", sa.String(length=45), nullable=True),
            sa.Column("user_agent", sa.Text(), nullable=True),
            sa.Column("created_at", sa.DateTime(timezone=True), nullable=False),
            sa.ForeignKeyConstraint(["task_id"], ["tasks.id"], ondelete="CASCADE"),
            sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="SET NULL"),
            sa.PrimaryKeyConstraint("id"),
        )
        op.create_index(
            "ix_task_activities_created_at",
            "task_activities",
            ["created_at"],
            unique=False,
        )
        op.create_index(
            "ix_task_activities_created_desc",
            "task_activities",
            [sa.text("created_at DESC")],
            unique=False,
        )
        op.create_index(
            "ix_task_activities_task_id", "task_activities", ["task_id"], unique=False
        )
        op.create_index(
            "ix_task_activities_task_type",
            "task_activities",
            ["task_id", "activity_type"],
            unique=False,
        )
        op.create_index(
            "ix_task_activities_user_created",
            "task_activities",
            ["user_id", "created_at"],
            unique=False,
        )
        op.create_index(
            "ix_task_activities_user_id", "task_activities", ["user_id"], unique=False
        )
        op.create_index(
            "ix_task_activities_activity_type",
            "task_activities",
            ["activity_type"],
            unique=False,
        )
        # ### end Alembic commands ###

        logger.info(f"Successfully applied migration {revision}")
    except Exception as e:
        logger.error(f"Failed to apply migration {revision}: {str(e)}")
        raise


def downgrade() -> None:
    """
    Rollback the migration.

    This function should safely undo all changes made in upgrade().
    """
    logger.info(f"Rolling back migration {revision}")

    # Get database dialect for conditional operations
    connection = op.get_bind()
    dialect_name = connection.dialect.name

    try:
        # ### commands auto generated by Alembic - please adjust! ###
        op.drop_index("ix_task_activities_activity_type", table_name="task_activities")
        op.drop_index("ix_task_activities_user_id", table_name="task_activities")
        op.drop_index("ix_task_activities_user_created", table_name="task_activities")
        op.drop_index("ix_task_activities_task_type", table_name="task_activities")
        op.drop_index("ix_task_activities_task_id", table_name="task_activities")
        op.drop_index("ix_task_activities_created_desc", table_name="task_activities")
        op.drop_index("ix_task_activities_created_at", table_name="task_activities")
        op.drop_table("task_activities")
        # ### end Alembic commands ###

        logger.info(f"Successfully rolled back migration {revision}")
    except Exception as e:
        logger.error(f"Failed to rollback migration {revision}: {str(e)}")
        raise


# Helper functions for common migration tasks
def create_index_if_not_exists(index_name: str, table_name: str, columns: list):
    """Create an index only if it doesn't already exist."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    indexes = [idx["name"] for idx in inspector.get_indexes(table_name)]

    if index_name not in indexes:
        op.create_index(index_name, table_name, columns)
        logger.info(f"Created index {index_name} on {table_name}")
    else:
        logger.info(f"Index {index_name} already exists on {table_name}")


def drop_index_if_exists(index_name: str, table_name: str):
    """Drop an index only if it exists."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    indexes = [idx["name"] for idx in inspector.get_indexes(table_name)]

    if index_name in indexes:
        op.drop_index(index_name, table_name)
        logger.info(f"Dropped index {index_name} from {table_name}")
    else:
        logger.info(f"Index {index_name} does not exist on {table_name}")


def add_column_if_not_exists(table_name: str, column: sa.Column):
    """Add a column only if it doesn't already exist."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    columns = [col["name"] for col in inspector.get_columns(table_name)]

    if column.name not in columns:
        op.add_column(table_name, column)
        logger.info(f"Added column {column.name} to {table_name}")
    else:
        logger.info(f"Column {column.name} already exists in {table_name}")


def drop_column_if_exists(table_name: str, column_name: str):
    """Drop a column only if it exists."""
    connection = op.get_bind()
    inspector = sa.inspect(connection)
    columns = [col["name"] for col in inspector.get_columns(table_name)]

    if column_name in columns:
        op.drop_column(table_name, column_name)
        logger.info(f"Dropped column {column_name} from {table_name}")
    else:
        logger.info(f"Column {column_name} does not exist in {table_name}")
